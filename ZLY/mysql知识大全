http://c.biancheng.net/mysql/10/
有这一个就够了！！！！



MySQL:
	索引：提升查找速度的一种手段
	分类：B+树、哈希、全文、RTree
关系数据模型的完整性约束：
	实体完整性
	参照完整性
	用户自定义的完整性
数据库系统的三级模式结构：
	外模式：数据库中全体数据的逻辑结构和特征的描述
	模式
	内模式
数据库数据类型：
	整型：
	  tinyiint,smallint,mediumint,int,bigint(1字节、2字节、3字节、4字节、8字节)——都是有符号型
	  括号只是表示显示的长度，如果不足长度，需要补零，超过长度，仍然完整显示
	小数：
  浮点数：
    Float
    double
  定点数：decimal
连接查询：同时设计多个表查询
等值连接：
自然连接：	去除重复列
非等值连接
自身连接：
  一个表与自己连接
  需要给表起别名以示区别
	由于所有属性名都是同名属性，因此必须使用别名前缀
	外连接：以表为连接主体，按照某周条件连接起来，也会输出不满足条件的表
	左连接：输出左关系所有元组
	右连接：输出右关系所有元组
	复合条件连接：
	嵌套查询：
	子查询：
	不能使用ORDER BY子句
	ORDER BY子句只对最终查询结果排序
	不相关子查询：子查询条件不依赖于父查询
	相关子查询：子查询的查询条件依赖于父查询
	视图：
	虚表，是从一个或几个基本表导出来的表，数据库中只存放视图的定义，不存放视图对应的数据
	行列子集视图：视图从单个基本表刀殂，并且只是去掉了基本表的某些行和某些列，保留了主码
	作用：
	能简化用户的操作，用户可以从多个角度去看待数据库
	为数据提供安全保护
	相当于给用户一个权限
	索引：索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构
	顺序方问：
	从头到尾遍历整个表，找到符合的数据
	索引访问：
	索引是存储引擎用于快速找到记录的一种数据结构.
	通过遍历索引来直接访问表中记录行的方式，查找数据时，直接根据列上的索引找到对应记录行的位置，从而快捷的查找到数据。索引存储了指定列数据值的指针
	索引的问题：
	索引占用空间
	减缓了插入删除的速度
	索引分类：
	m阶-B树索引——主要应用在mongoDB
	数据库索引存储在磁盘上，利用索引查询的时候，只能逐一加载每个磁盘也，这里的磁盘页对应着索引树的节点，磁盘的IO次数取决于索引树的高度，因此需要将树结构变得矮胖；
	相当于多路平衡查找树，相对于二叉查找树更加的矮胖，查找时间短
	根节点至少有两个子女
	每个节点有k-1个元素，m/2<=k<=m,有k个子树，k取决于磁盘页的大小
	节点的元素从大到小排列，是子树的值域划分
	叶子节点都在同一层
	比较的次数不必二叉查找树要少，但是磁盘io的次数少了很多，比较的时间和磁盘io的时间比起来，不算什么
	M阶B+树索引——主要应用在关系数据库
	有k个子树的中间节点包含k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点；
	中间节点元素都同时存在于子节点，在子节点元素中式最大或者最小的元素
	所有叶子节点中包含了全部元素的信息，即指向汉这些元素记录的指针，并且叶子节点本身一关键的大小自小而大的顺序连接
	聚集索引中，叶子节点直接包含卫星元素，非聚集索引中，叶子节点带有指向卫星数据的指针
	B-树的范围索引比较麻烦，需要中序遍历
	B树的范围索引到达叶子节点之后，可以直接找到后面的元素,
	B+树的特点：IO次数比较少，查询性能稳定，范围查询简单
	聚簇索引和非聚簇索引：逻辑结构都是B+树
	聚簇索引的数据页存放的是完整的记录
	非聚簇索引：数据页只存指向记录的地址信息
函数依赖：关系R（U）上，U是属性集合，X,Y是U上的子集，在关系r上，r中不可能存在两个元组在X上的值相等，但是在Y上不相等。称为X->Y
	非平凡函数依赖：Y不是X的子集（复习的时候举个例子哈）
	平凡函数依赖：Y是X的子集（必然成立的）
	完全函数依赖：X的真子集不能函数确定Y
	部分函数依赖：Y不完全依赖X，Y依赖X的真子集
	传递函数依赖：x->y,y->z,都是非平凡函数依赖（举个例子哈）
范式：
	1NF：关系中所有的属性都是不可分的基本关系数据项
	2NF：非主属性完全函数依赖于任何一个候选码
	3NF：取消传递函数依赖
	BCNF：属于第一范式得时候，X->y,y非平凡依赖x,x必含有码：
	Y都是完全依赖于x
	所有主属性对每个不包含他得码，也是完全函数依赖
	没有任何属性完全函数依赖于非码的任何一组属性
好的模式不会出现以下情况：
	数据冗余
	插入异常：插入一个新的学生，没分配系主任，就会变成none
	更新异常：更换系主任，这个系得学生都要删除
	删除异常：删除学生信息的时候，连系主任和系都删掉了
事务：用户定义的一些列操作，这些操作要么全都做，要么全不做，是一系列不可分割的工作单位。
	以begin transaction开始，以commit（提交）,rollback（回滚）结束
	Commit表示提交，提交事务所有的操作，将事务中对数据库的更新写回磁盘上的物理数据库中去
	Rollback表示回滚，在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始的状态
	ACID特性：
	原子性：要么都做，要不都不做
	一致性：只包含事务成功提交的结果
	隔离性：一个事务的内部操作和使用的数据对另一个并发的事务时隔离的
	持续性：一旦提交，这种改变时永久的
	恢复技术：根据存储在系统别处的冗余数据来重建——冗余
	数据转储：定期将整个数据库复制到其他地方保存起来，但只能恢复到转储时的状态，需要重新执行转储之后的所有事务
	静态转储：无事务运行时转储，可用性比较差
	动态转储：转储期间允许对数据库进行存储或修改，一致性有问题，需要有日志文件来恢复
	登记日志文件：记录事务对数据库的更新操作的文件
	事务的开始
	事务的结束
	事务的更新操作
	恢复方法：
	系统故障：——软故障
	正向扫描日志文件：
	对已经提交的事务加入重做队列
	对没有提交的事务加入撤销队列
	撤销操作：反向扫描日志，对撤销事务的更新操作做逆向操作
	重做操作：正向扫描日志，对重做事务重新执行日志的操作
	介质故障：——硬故障——数据转储
	装入最近一次转储的数据库备份；对于动态转储，还需要装入转储时的日志文件，对日志文件采用系统故障的方式（重做+撤销）恢复数据库一致性
	装入转储之后的日志文件，正向扫描，只重做已提交的事务
并发带来的数据不一致性：
	丢失修改：两个事务读同一个数据并修改，后面提交的结果，破坏了前一个结果
	不可重复读：
	T2修改了数据，T1在读的时候发现根上次不一样，无法重现上次的值
	幻影：
	T2删除了数据，T1再读的时候发现神秘消失了
	T2添加了数据，T1再按照原来的条件读的时候，发现多了数据
	读脏数据：T1修改数据后，被撤回，但是T2在撤回之前读的，读到了T1修改之后的无效数据
并发控制：
	封锁：
	排他锁：X锁：T对A加X锁，只允许T读取和修改A，其他都不能加锁了
	共享锁：S锁：T只能读取A，其他也能加S锁
	会引起活锁和死锁：
	活锁：T2永远等待，系统总是不处理它的请求
	先来先服务，可以解决
	死锁：T1和T2分别持有对方需要的资源。并且请求：
	诊断：
	超时法：事务等待的时间超过了时间限制，就认为发生了死锁
	等待图法：如果有环就认为死锁，T1等待T2，t1指向t2
	解除死锁：
	选择一个处理死锁代价最小的事务，将其撤销
	释放这个事务的所有锁，时其他事务继续运行
	时间戳
	乐观控制法
	多版本并发控制
存储过程：
	一个预编译好的代码块，可以提高执行效率，网络传输的时候不需要传输一个大的sql语句集，只需要传输过程的名称和参数，通讯速率高；通过过程存储，能够使没有权限的用户在控制之下简洁地存储数据库，从而确保数据的安全；如果企业规则发生的变化，可以直接修改过程，而不需要大量的修改代码。

